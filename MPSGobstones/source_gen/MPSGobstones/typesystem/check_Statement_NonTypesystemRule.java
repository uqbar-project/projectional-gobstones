package MPSGobstones.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import GsInspectorPresenter.behavior.FeatureRestriction__BehaviorDescriptor;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public class check_Statement_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_Statement_NonTypesystemRule() {
  }
  public void applyRule(final SNode statement, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    List<SNode> restrictions = SLinkOperations.getChildren(SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(statement, MetaAdapterFactory.getConcept(0x329ed8d6630b448dL, 0xb0add0e71fe3ca82L, 0x5b1857b73e39d0d3L, "GsInspectorPresenter.structure.MainProgram"), false, false), MetaAdapterFactory.getReferenceLink(0x329ed8d6630b448dL, 0xb0add0e71fe3ca82L, 0x5b1857b73e39d0d3L, 0x7be35bb43cb810f0L, "exercise")), MetaAdapterFactory.getContainmentLink(0x329ed8d6630b448dL, 0xb0add0e71fe3ca82L, 0x57e1fc765aac1178L, 0xc13f236fe9f86d9L, "restrictions"));
    if (ListSequence.fromList(restrictions).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return (boolean) FeatureRestriction__BehaviorDescriptor.isRestricted_id5f2KzShMWtb.invoke(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0x329ed8d6630b448dL, 0xb0add0e71fe3ca82L, 0xc13f236fe9f86ceL, 0xc13f236fe9faa18L, "restriction")), statement);
      }
    })) {
      {
        MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(statement, "Est\u00e1 prohibido usar " + SConceptOperations.conceptAlias(SNodeOperations.getConcept(statement)), "r:a3d7b434-0554-4138-a6f0-66b6a9099d5b(MPSGobstones.typesystem)", "6035600022472278112", null, errorTarget);
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return MetaAdapterFactory.getConcept(0xcb8c78e791643a8L, 0x8d8ea292ead7a894L, 0xa107f9943a750c1L, "MPSGobstones.structure.Statement");
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return true;
  }
}
