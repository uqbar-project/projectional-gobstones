package JavaGobstones.models;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.SortedSet;
import jetbrains.mps.internal.collections.runtime.SortedSetSequence;
import java.util.TreeSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class Board {
  private Tuples._2<Integer, Integer> size = MultiTuple.<Integer,Integer>from(10, 10);
  private Explosion explosion = null;
  private Tuples._2<Integer, Integer> claw = MultiTuple.<Integer,Integer>from(0, 0);
  private SortedSet<Cell> cells = SortedSetSequence.fromSet(new TreeSet<Cell>());

  public boolean isExploded() {
    return explosion != null;
  }

  public void moveClaw(Direction direction) {
    setClawPosition(direction.move(claw));
  }

  public void setClawPosition(final Tuples._2<Integer, Integer> position) {
    whenValidPosition(position, new Runnable() {
      public void run() {
        claw = position;
      }
    });
  }

  public void whenValidPosition(Tuples._2<Integer, Integer> position, Runnable action) {
    if (isValidPosition(position)) {
      action.run();
    } else {
      doExplode("El cabezal intent\u00f3 moverse fuera del tablero");
    }
  }

  public void doExplode(String cause) {
    // The domain can produce only one explosion for a given runtime 
    if (explosion == null) {
      explosion = new Explosion(cause);
    }
  }
  public boolean isValidPosition(Tuples._2<Integer, Integer> position) {
    return (int) position._0() >= 0 && (int) position._1() >= 0 && (int) position._0() < (int) size._0() && (int) position._1() < (int) size._1();
  }

  public void addStones(Color color, int quantity) {
    Cell cell = getOrCreateCell();
    cell.addStones(color, quantity);
    validateCell(cell);
  }

  private Cell getOrCreateCell() {
    Cell currentCell = currentCell();
    if (currentCell == null) {
      currentCell = new Cell((int) claw._0(), (int) claw._1());
      SortedSetSequence.fromSet(cells).addElement(currentCell);
    }
    return currentCell;
  }

  public Cell cellAt(final int x, final int y) {
    Cell cell = SortedSetSequence.fromSet(cells).findFirst(new IWhereFilter<Cell>() {
      public boolean accept(Cell it) {
        return (int) it.pos._0() == x && (int) it.pos._1() == y;
      }
    });
    if ((int) claw._0() == x && (int) claw._1() == y) {
      if (cell == null) {
        cell = new Cell(x, y);
      }
      cell.setSelected(true);
    }
    return cell;
  }

  private Cell currentCell() {
    return SortedSetSequence.fromSet(cells).findFirst(new IWhereFilter<Cell>() {
      public boolean accept(Cell it) {
        return MultiTuple.eq(it.pos, claw);
      }
    });
  }

  private void validateCell(Cell cell) {
    if (!(cell.isValid())) {
      doExplode("Se intent\u00f3 realizar una operaci\u00f3n inv\u00e1lida sobre una celda");
    } else if (cell.isEmpty()) {
      SortedSetSequence.fromSet(cells).removeElement(cell);
    }
  }
  public int rowCount() {
    return (int) size._1();
  }
  public int columnCount() {
    return (int) size._0();
  }
}
