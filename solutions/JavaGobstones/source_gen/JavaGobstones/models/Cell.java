package JavaGobstones.models;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class Cell implements Comparable {
  private boolean selected = false;
  public final int x;
  public final int y;

  private int blue = 0;
  private int black = 0;
  private int red = 0;
  private int green = 0;

  public Cell(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public Cell(int x, int y, int blue, int black, int red, int green) {
    this(x, y);
    this.blue = blue;
    this.black = black;
    this.red = red;
    this.green = green;
  }

  public Cell clone() {
    return new Cell(x, y, blue, black, red, green);
  }

  public void addStones(Color color, int quantity) {
    // While switch statements are trully awfull 
    // it is very important to minimize object creation related to cells 

    switch (color) {
      case red:
        red += quantity;
        break;
      case black:
        black += quantity;
        break;
      case blue:
        blue += quantity;
        break;
      case green:
        green += quantity;
        break;
      default:
    }
  }

  public int quantityOf(Color color) {
    switch (color) {
      case red:
        return red;
      case black:
        return black;
      case blue:
        return blue;
      case green:
        return green;
      default:
        throw new RuntimeException("Error inesperado. Color inexistente.");
    }
  }

  public boolean isEmpty() {
    return allStones(new _FunctionTypes._return_P1_E0<Boolean, Integer>() {
      public Boolean invoke(Integer quantity) {
        return quantity == 0;
      }
    });
  }

  public boolean isValid() {
    return allStones(new _FunctionTypes._return_P1_E0<Boolean, Integer>() {
      public Boolean invoke(Integer quantity) {
        return quantity >= 0;
      }
    });
  }

  private boolean allStones(_FunctionTypes._return_P1_E0<? extends Boolean, ? super Integer> applicative) {
    return applicative.invoke(blue) && applicative.invoke(black) && applicative.invoke(red) && applicative.invoke(green);
  }

  public int compareTo(Object object) {
    Cell other = ((Cell) object);
    if (y < other.y) {
      return -1;
    }
    if (y > other.y) {
      return 1;
    }
    if (x < other.x) {
      return -1;
    }
    if (x > other.x) {
      return 1;
    }
    return 0;
  }

  public boolean isSelected() {
    return selected;
  }
  public void setSelected(boolean selected) {
    this.selected = selected;
  }

  public int getBlue() {
    return blue;
  }
  public int getBlack() {
    return black;
  }
  public int getRed() {
    return red;
  }
  public int getGreen() {
    return green;
  }
}
